import*as THREE from"./three.module.min.js";import{OrbitControls}from"./OrbitControls.js";import TWEEN from"./tween.module.js";const ANGLES_NUM=5,FIGURE_HEIGHT=5.5,FIGURE_RADIUS=5,CURV_COEF=2,LINES_COLOR="#ffffff",SPHERE_COLORS=["#c0392b","#fa6727","#f8104b","#7cbb3b","#29b579","#1d7372","#00a6b4","#1d7372","#2c92e5","#2dcc70"],parent=document.querySelector(".canvas__window"),scene=new THREE.Scene,camera=new THREE.PerspectiveCamera(70,window.innerWidth/window.innerHeight,1,1e3);camera.position.set(-.19058996153741722,-8.456740289133542,1.5396789741867494);const renderer=new THREE.WebGLRenderer({antialias:!0});renderer.setSize(parent.offsetWidth,parent.offsetWidth),renderer.setClearColor(4210509,0),parent.appendChild(renderer.domElement);const controls=new OrbitControls(camera,renderer.domElement);controls.target.set(-.19058996153741756,-4.083425180755162,-.473864393368694),controls.update(),controls.addEventListener("change",()=>{console.log("controls.target"),console.log(controls.target),console.log("camera.position"),console.log(camera.position)});const materialLine=new THREE.LineBasicMaterial({color:"#ffffff"}),polygonCoords1=[];for(let e=0;e<=5;e++){const t=2*e*Math.PI/5;polygonCoords1.push(new THREE.Vector3(1===e||4===e?5*Math.sin(t)*2:5*Math.sin(t),5*-Math.cos(t),0))}const geometry1=(new THREE.BufferGeometry).setFromPoints(polygonCoords1),polygon1=new THREE.Line(geometry1,materialLine);polygon1.rotateX(-Math.PI),scene.add(polygon1);const polygonCoords2=[];for(let e=0;e<=5;e++){const t=2*e*Math.PI/5;polygonCoords2.push(new THREE.Vector3(1===e||4===e?5*Math.sin(t)*2:5*Math.sin(t),5*-Math.cos(t),5.5))}const geometry2=(new THREE.BufferGeometry).setFromPoints(polygonCoords2),polygon2=new THREE.Line(geometry2,materialLine);polygon2.rotateX(-Math.PI),scene.add(polygon2);for(let e=0;e<5;e++){const t=[];for(let o=0;o<10;o++){const o=2*e*Math.PI/5;t.push([new THREE.Vector3(1===e||4===e?5*Math.sin(o)*2:5*Math.sin(o),5*-Math.cos(o),0),new THREE.Vector3(1===e||4===e?5*Math.sin(o)*2:5*Math.sin(o),5*-Math.cos(o),5.5)])}const o=(new THREE.BufferGeometry).setFromPoints(t[e]),n=new THREE.Line(o,materialLine);n.rotateX(-Math.PI),scene.add(n)}for(let e=0;e<10;e++){const t=2*e*Math.PI/5,o=new THREE.SphereGeometry(.2,32,16),n=new THREE.MeshBasicMaterial({color:SPHERE_COLORS[e],opacity:1}),r=new THREE.Mesh(o,n);r.userData={"data-tab":"tab-"+e},e<5?r.position.set(1===e||4===e?5*Math.sin(t)*-Math.PI*.315*2:5*Math.sin(t)*-Math.PI*.31,5*-Math.cos(t)*-Math.PI*.31,0):r.position.set(6===e||9===e?5*Math.sin(t)*-Math.PI*.315*2:5*Math.sin(t)*-Math.PI*.31,5*-Math.cos(t)*-Math.PI*.31,-5.5),scene.add(r)}const animate=()=>{requestAnimationFrame(animate),renderer.render(scene,camera),TWEEN.update()};animate();const raycaster=new THREE.Raycaster,animationHoverHandler=e=>{const t=new THREE.Vector2((e.clientX-renderer.domElement.getBoundingClientRect().left)/renderer.domElement.clientWidth*2-1,-(e.clientY-renderer.domElement.getBoundingClientRect().top)/renderer.domElement.clientHeight*2+1),o=scene.children.filter(e=>e.isMesh);raycaster.setFromCamera(t,camera);const n=raycaster.intersectObjects(o,!0);if(n.length>0){const e=n[0].object;console.log(e),new TWEEN.Tween(e.material.opacity).to({opacity:.1},500).easing(TWEEN.Easing.Linear.None).onUpdate((function(){e.material.copy(e.material)})).start()}else o.forEach(e=>{new TWEEN.Tween(e.material.opacity).to({opacity:1},500).easing(TWEEN.Easing.Linear.None).onUpdate((function(){e.material.copy(e.material)})).start()})};renderer.domElement.addEventListener("pointermove",animationHoverHandler);